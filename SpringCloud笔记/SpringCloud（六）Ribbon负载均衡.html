<html>
<head>
  <title>SpringCloud（六）Ribbon负载均衡</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/600986 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="787"/>
<h1>SpringCloud（六）Ribbon负载均衡</h1>

<div>
<span><div><h2>Ribbon概述</h2><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">Spring Cloude Ribbon是基于Netfilx Ribbon实现的一套客户端 负载均衡的工具，简单说，Ribbon是Netfilix发布的开源项目，主要功能就是提供</span> <span style="font-weight: bold;-en-paragraph:true;">客户端的软件负载均衡算法</span><span style="-en-paragraph:true;">，将Netfilix的中间层服务连接在一起，Ribbon客户端组件提供了一系列完善的配置项如连接超时，重试等，简单说，就是在配置文件中列出Load Balance后面的所有机器，Ribbon会自动的帮助你基于某种算法规则（简单轮询，随机连接等）去连接这些机器，也可以使用Ribbon自定义负载均衡算法。LB，即负载均衡，在微服务或者分布式集群中常用的一种应用。负载均衡就是将用户的请求平摊的分配到多个服务上，从而达到HA，常见的负载均衡软件有Nginx，LVS，硬件F5等</span></div><h2>Ribbon配置初步</h2><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">由于Ribbon是客户端的负载均衡工具，所以我们需要修改的是客户端项目microservicecloud-consumer-dept-80</span></div><h3>POM.xml文件</h3><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&lt;!-- Ribbon相关 --&gt;</div><div>&lt;dependency&gt;</div><div>  &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</div><div>  &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt;</div><div>&lt;/dependency&gt;</div><div>&lt;dependency&gt;</div><div>  &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</div><div>  &lt;artifactId&gt;spring-cloud-starter-ribbon&lt;/artifactId&gt;</div><div>&lt;/dependency&gt;</div><div>&lt;dependency&gt;</div><div>  &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</div><div>  &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt;</div><div>&lt;/dependency&gt;</div><div>&lt;dependency&gt;</div><div>  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div>  &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</div><div>&lt;/dependency&gt;</div></div><h3><br/></h3><h3>修改application.yml文件，添加Eureka的服务注册地址</h3><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>server:</div><div>  port: 80</div><div>eureka:</div><div>  client:</div><div>    register-with-eureka: false #自己不能注册</div><div>    service-url:</div><div>      defaultZone: http://eureka7001.com:7001/eureka/,http://eureka7002.com:7002/eureka/,http://eureka7003.com:7003/eureka/  </div></div><div><br/></div><h3>修改客户端配置类</h3><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">由于客户端使用restTemplate访问服务端中的数据接口，restTemplate配置在服务端的配置类中，所以修改如下</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>@Configuration</div><div>public class ConfigBean {</div><div>        @Bean</div><div>        @LoadBalanced</div><div>        public RestTemplate geRestTemplate(){</div><div>                return new RestTemplate();</div><div>        }</div><div>}</div></div><div><br/></div><h3>修改客户端主程序启动类</h3><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>@SpringBootApplication</div><div>@EnableEurekaClient</div><div>public class DeptConsumer80_App {</div><div>        public static void main(String[] args) {</div><div>                SpringApplication.run(DeptConsumer80_App.class, args);</div><div>        }</div><div>}</div></div><div><br/></div><h3>修改客户端访问类DeptController_Consumer.java</h3><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>private static final String REST_URL_PREFIX = &quot;http://MICROSERVICECLOUD-DEPT&quot;;</div></div><div><br/></div><h3>测试</h3><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">启动7001,7002,7003三个服务注册中心，启动8001服务提供者，启动80客户端，使用<a href="http://localhost/consumer/dept/list">http://localhost/consumer/dept/list</a>可以渠道对应的数据，在DeptController_Consumer使用的是<a href="http://microservicecloud-dept/">http://MICROSERVICECLOUD-DEPT</a>服务名称来调用服务的接口，相比之前的<a href="http://localhost:8001/">http://localhost:8001</a>，Ribbon和Eureka整合后，Consumer可以直接通过服务名称来调用服务，而不再关心地址和端口号。</span></div><h2>Ribbon负载均衡</h2><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">目前只有一个microservicecloud-provider-dept-8001服务提供者，为了实现Ribbon的负载均衡，所以我们需要多个服务提供者实例，新建microservicecloud-provider-dept-8002，microservicecloud-provider-dept-8003两个Module。参考8001的pom.xml文件修改8002,8003的pom.xml文件。拷贝8001中的所以类和配置文件mybatis和application.yml文件，将主启动类修改为对应的名字</span></div><h3>microservicecloud-provider-dept-8002服务提供者</h3><h4>使用的数据库SQL语句</h4><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>DROP DATABASE IF EXISTS cloudDB02 ;</div><div>CREATE DATABASE cloudDB02 CHARACTER SET UTF8 ;</div><div>USE cloudDB02 ;</div><div>CREATE TABLE dept (</div><div>  deptno BIGINT NOT NULL PRIMARY KEY AUTO_INCREMENT,</div><div>  dname VARCHAR (60),</div><div>  db_source VARCHAR (60)</div><div>) ;</div><div>INSERT INTO dept(dname,db_source) VALUES('开发部',DATABASE());</div><div>INSERT INTO dept(dname,db_source) VALUES('人事部',DATABASE());</div><div>INSERT INTO dept(dname,db_source) VALUES('财务部',DATABASE());</div><div>INSERT INTO dept(dname,db_source) VALUES('市场部',DATABASE());</div><div>INSERT INTO dept(dname,db_source) VALUES('运维部',DATABASE());</div></div><div><br/></div><h4>Application.yml文件</h4><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>server:</div><div>  port: 8002</div><div>  </div><div>mybatis:</div><div>  config-location: classpath:mybatis/mybatis.cfg.xml        # mybatis配置文件所在路径</div><div>  type-aliases-package: com.luo.springcloud.entities        # 所有Entity别名类所在包</div><div>  mapper-locations:</div><div>  - classpath:mybatis/mapper/**/*.xml                       # mapper映射文件</div><div>    </div><div>spring:</div><div>   application:</div><div>    name: microservicecloud-dept</div><div>   datasource:</div><div>    type: com.alibaba.druid.pool.DruidDataSource            # 当前数据源操作类型</div><div>    driver-class-name: org.gjt.mm.mysql.Driver              # mysql驱动包</div><div>    url: jdbc:mysql://localhost:3306/cloudDB02              # 数据库名称</div><div>    username: root</div><div>    password: 1234</div><div>    dbcp2:</div><div>      min-idle: 5                                           # 数据库连接池的最小维持连接数</div><div>      initial-size: 5                                       # 初始化连接数</div><div>      max-total: 5                                          # 最大连接数</div><div>      max-wait-millis: 200      </div></div><div><br/></div><h3>microservicecloud-provider-dept-8003服务提供者</h3><h4>使用的数据库SQL语句</h4><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>DROP DATABASE IF EXISTS cloudDB03 ;</div><div>CREATE DATABASE cloudDB03 CHARACTER SET UTF8 ;</div><div>USE cloudDB03 ;</div><div>CREATE TABLE dept (</div><div>  deptno BIGINT NOT NULL PRIMARY KEY AUTO_INCREMENT,</div><div>  dname VARCHAR (60),</div><div>  db_source VARCHAR (60)</div><div>) ;</div><div>INSERT INTO dept(dname,db_source) VALUES('开发部',DATABASE());</div><div>INSERT INTO dept(dname,db_source) VALUES('人事部',DATABASE());</div><div>INSERT INTO dept(dname,db_source) VALUES('财务部',DATABASE());</div><div>INSERT INTO dept(dname,db_source) VALUES('市场部',DATABASE());</div><div>INSERT INTO dept(dname,db_source) VALUES('运维部',DATABASE());</div></div><div><br/></div><h4>Application.yml文件</h4><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>server:</div><div>  port: 8003</div><div>  </div><div>mybatis:</div><div>  config-location: classpath:mybatis/mybatis.cfg.xml        # mybatis配置文件所在路径</div><div>  type-aliases-package: com.luo.springcloud.entities        # 所有Entity别名类所在包</div><div>  mapper-locations:</div><div>  - classpath:mybatis/mapper/**/*.xml                       # mapper映射文件</div><div>    </div><div>spring:</div><div>   application:</div><div>    name: microservicecloud-dept</div><div>   datasource:</div><div>    type: com.alibaba.druid.pool.DruidDataSource            # 当前数据源操作类型</div><div>    driver-class-name: org.gjt.mm.mysql.Driver              # mysql驱动包</div><div>    url: jdbc:mysql://localhost:3306/cloudDB03              # 数据库名称</div><div>    username: root</div><div>    password: 1234</div><div>    dbcp2:</div><div>      min-idle: 5                                           # 数据库连接池的最小维持连接数</div><div>      initial-size: 5                                       # 初始化连接数</div><div>      max-total: 5                                          # 最大连接数</div><div>      max-wait-millis: 200      </div></div><h3>微服务提供者说明</h3><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">三个微服务提供者连接不同的数据库，因此在application.yml文件中，我们需要修改端口号和连接的数据库，注意的是三个微服务提供者的微服务名字保持一样，也就是如下的配置信息</span></div><div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>spring:   application:    name: microservicecloud-dept</div></div><br/></div><div><br/></div><h3>负载均衡自测</h3><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">访问连接<a href="http://localhost:8001/dept/list">http://localhost:8001/dept/list</a>，<a href="http://localhost:8002/dept/list">http://localhost:8002/dept/list</a>，<a href="http://localhost:8003/dept/list">http://localhost:8003/dept/list</a>得到不同数据库数据，当我们启动服务注册中心7001,7002,7003,再启动80客户端，这个时候访问localhost/consumer/dept/list，每次刷新就会得到不同数据库的数据。这就是Ribbon默认的轮询算法的负载均衡。</span></div><h2>Ribbon核心组件IRule</h2><h4>Ribbon负载均衡算法</h4><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">Ribbon默认提供的是轮询的负载均衡算法，完整了还有如下</span></div><table style="border-collapse: collapse; min-width: 100%;"><colgroup><col style="width: 130px;"></col><col style="width: 130px;"></col></colgroup><tbody><tr><td style="width: 130px; padding: 8px; border: 1px solid;"><div>RoundRobinRule</div></td><td style="width: 130px; padding: 8px; border: 1px solid;"><div>轮询</div></td></tr><tr><td style="width: 130px; padding: 8px; border: 1px solid;"><div>RandomRule</div></td><td style="width: 130px; padding: 8px; border: 1px solid;"><div>随机</div></td></tr><tr><td style="width: 130px; padding: 8px; border: 1px solid;"><div>AvaliabilityFilteringRule</div></td><td style="width: 130px; padding: 8px; border: 1px solid;"><div>会先过滤由于多次访问故障而处于断路器跳闸的状态的服务和并发的连接数量超过阈值的服务，然后对剩余的服务列表按照轮询策略</div></td></tr><tr><td style="width: 130px; padding: 8px; border: 1px solid;"><div>WeightedResponseTimeRule</div></td><td style="width: 130px; padding: 8px; border: 1px solid;"><div>根据平均响应时间计算所有服务的权重，响应时间越快服务权重越大</div></td></tr><tr><td style="width: 130px; padding: 8px; border: 1px solid;"><div>RetryRule</div></td><td style="width: 130px; padding: 8px; border: 1px solid;"><div>先按照RoundRobinRule策略获取服务，如果获取服务失败会在指定时间内重试</div></td></tr><tr><td style="width: 130px; padding: 8px; border: 1px solid;"><div>BestAvailableRule</div></td><td style="width: 130px; padding: 8px; border: 1px solid;"><div>会先过滤掉由于多次访问故障二处于断路器跳闸状态的服务，然后选择一个并发量最小的服务</div></td></tr><tr><td style="width: 130px; padding: 8px; border: 1px solid;"><div>ZoneAvoidanceRule</div></td><td style="width: 130px; padding: 8px; border: 1px solid;"><div>默认规则，复合判断server所在的区域的性能和server的可用性选择服务器</div></td></tr></tbody></table><h4>Ribbon负载均衡算法使用方法</h4><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">在客户端的配置类ConfigBean.java中添加IRule的实现</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>@Configuration</div><div>public class ConfigBean {</div><div>        @Bean</div><div>        @LoadBalanced</div><div>        public RestTemplate geRestTemplate(){</div><div>                return new RestTemplate();</div><div>        }</div><div>        @Bean</div><div>        public IRule myRule(){</div><div>                return new RandomRule();</div><div>        }</div><div>}</div></div><h2><br/></h2><h2>Ribbon自定义</h2><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">如果不使用Ribbon默认的七种负载均衡算法，这个时候就需要使用自定义负载均衡算法</span></div><h3>客户端主启动类使用注解@RibbonClient</h3><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>@SpringBootApplication</div><div>@EnableEurekaClient</div><div>@RibbonClient(name=&quot;MICROSERVICECLOUD-DEPT&quot;,configuration=MySelfRule.class)</div><div>public class DeptConsumer80_App {</div><div>        public static void main(String[] args) {</div><div>                SpringApplication.run(DeptConsumer80_App.class, args);</div><div>        }</div><div>}</div></div><div><br/></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="font-weight: bold;-en-paragraph:true;">特此说明</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">RibbonClient注解中的MySelfRule类使我们自定义负载均衡算法的类，但是，这个自定义配置类不能放在@ComponentScan所扫描的当前包下以及子包下，否则我们这个自定义的配置类会被所有的Ribbon客户端所共享，也就说，达不到我们特殊化定制的目的。举例说明，自定义配置类不能放在项目主启动类所有的包以及子包下，因为主启动类使用注解@SpringBootApplication，这个注解点进去使用@ComponentScan注解</span></div><h3>自定义负载均衡算法</h3><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">轮询算法中每一个服务轮询一次，现在需求是每一个服务调用五次后在轮询下一个服务</span></div><h3>自定义配置类</h3><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>package com.luo.myrule;</div><div>import org.springframework.context.annotation.Bean;</div><div>import org.springframework.context.annotation.Configuration;</div><div>import com.netflix.loadbalancer.IRule;</div><div>@Configuration</div><div>public class MySelfRule {</div><div>        @Bean</div><div>        public IRule myRule(){</div><div>                return new RandomRule_lky();</div><div>        }</div><div>}</div></div><div><br/></div><h3>自定义算法类</h3><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>package com.luo.myrule;</div><div>import java.util.List;</div><div>import com.netflix.client.config.IClientConfig;</div><div>import com.netflix.loadbalancer.AbstractLoadBalancerRule;</div><div>import com.netflix.loadbalancer.ILoadBalancer;</div><div>import com.netflix.loadbalancer.Server;</div><div>public class RandomRule_lky extends AbstractLoadBalancerRule{</div><div>        // total = 0 // 当total==5以后，我们指针才能往下走，</div><div>        // index = 0 // 当前对外提供服务的服务器地址，</div><div>        // total需要重新置为零，但是已经达到过一个5次，我们的index = 1</div><div>        // 分析：我们5次，但是微服务只有8001 8002 8003 三台，OK？</div><div>        private int total = 0;                     // 总共被调用的次数，目前要求每台被调用5次</div><div>        private int currentIndex = 0;      // 当前提供服务的机器号</div><div>        public Server choose(ILoadBalancer lb, Object key){</div><div>                if (lb == null) {</div><div>                        return null;</div><div>                }</div><div>                Server server = null;</div><div>                while (server == null) {</div><div>                        if (Thread.interrupted()) {</div><div>                                return null;</div><div>                        }</div><div>                        List&lt;Server&gt; upList = lb.getReachableServers();</div><div>                        List&lt;Server&gt; allList = lb.getAllServers();</div><div>                        int serverCount = allList.size();</div><div>                        if (serverCount == 0) {</div><div>                                return null;</div><div>                        }</div><div>//                   private int total = 0;                  // 总共被调用的次数，目前要求每台被调用5次//                   private int currentIndex = 0;   // 当前提供服务的机器号</div><div>            if(total &lt; 5)</div><div>            {</div><div>                    server = upList.get(currentIndex);</div><div>                    total++;</div><div>            }else {</div><div>                    total = 0;</div><div>                    currentIndex++;</div><div>                    if(currentIndex &gt;= upList.size())</div><div>                    {</div><div>                      currentIndex = 0;</div><div>                    }</div><div>            }                   </div><div>                        if (server == null) {</div><div>                                Thread.yield();</div><div>                                continue;</div><div>                        }</div><div>                        if (server.isAlive()) {</div><div>                                return (server);</div><div>                        }</div><div>                        server = null;</div><div>                        Thread.yield();</div><div>                }</div><div>                return server;</div><div>        }</div><div>        @Override</div><div>        public Server choose(Object key){</div><div>                return choose(getLoadBalancer(), key);</div><div>        }</div><div>        @Override</div><div>        public void initWithNiwsConfig(IClientConfig clientConfig){}</div><div>}</div></div><div><br/></div></div></span>
</div></body></html> 